<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake â€” Jungle Green</title>
  <style>
    :root{
      --bg: #e8f6ef;          /* pale mint */
      --panel: #ffffffcc;
      --jungle: #1f7a4c;      /* deep jungle green */
      --leaf: #2fb36b;        /* bright leaf */
      --accent: #9be5b8;      /* soft green accent */
      --muted: #2f3b35;
      --glass: rgba(255,255,255,0.6);
    }

    html,body{height:100%; margin:0;padding:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background: linear-gradient(180deg,var(--bg),#f4fff6); color:var(--muted);}
    .wrap {
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:28px;
    }

    .card {
      width:100%;
      max-width:920px;
      border-radius:14px;
      padding:20px;
      box-shadow: 0 12px 30px rgba(18,56,38,0.08);
      background: linear-gradient(180deg, rgba(255,255,255,0.9), var(--panel));
      display:grid;
      grid-template-columns: 1fr 300px;
      gap:18px;
    }

    @media (max-width:920px){
      .card { grid-template-columns: 1fr; }
    }

    header { grid-column: 1 / -1; text-align:center; }
    h1 { margin:6px 0; color:var(--jungle); font-size:1.6rem; }
    p.lead { margin:0; color: #35624a; font-size:0.95rem; }

    /* Game area */
    .game-area {
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
      justify-content:center;
      padding:10px;
    }

    .canvas-wrap {
      background: linear-gradient(180deg, #eaf6ee, #f2fff6);
      border-radius:10px;
      padding:10px;
      box-shadow: inset 0 2px 0 rgba(255,255,255,0.6);
    }

    canvas {
      display:block;
      background: linear-gradient(180deg, #f7fff7, #eefbf0);
      border-radius:8px;
      width:100%;
      max-width:720px;
      height:auto;
      touch-action: none;
      image-rendering: pixelated;
    }

    /* Controls panel */
    .panel {
      padding:12px;
      border-radius:10px;
      background:linear-gradient(180deg, rgba(255,255,255,0.98), rgba(250,255,250,0.9));
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:stretch;
    }

    .stat-row {
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:center;
    }

    .score {
      font-weight:700;
      color:var(--jungle);
      font-size:1.15rem;
    }

    .small {
      font-size:0.9rem;
      color:#4a6b59;
    }

    .controls {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    button {
      background: linear-gradient(180deg, var(--leaf), var(--jungle));
      border:none;
      color:white;
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 14px rgba(31,122,76,0.18);
    }
    button.ghost {
      background: transparent;
      color:var(--jungle);
      border:1px solid rgba(31,122,76,0.12);
      box-shadow:none;
    }

    .slider-row { display:flex; align-items:center; gap:10px; }
    input[type="range"] { width:100%; }

    .hint {
      font-size:0.85rem;
      color:#35624a;
      background: linear-gradient(90deg, rgba(155,229,184,0.15), rgba(255,255,255,0));
      padding:8px;
      border-radius:8px;
    }

    footer.small { grid-column: 1 / -1; text-align:center; color:#567b61; font-size:0.85rem; }

  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="Snake game">
      <header>
        <h1>Snake â€” Jungle Green</h1>
        <p class="lead">Classic snake with adjustable speed and scoring. Use Arrow keys or WASD. Mobile: tap canvas to start.</p>
      </header>

      <section class="game-area" aria-live="polite">
        <div class="canvas-wrap" style="width:100%;">
          <!-- We'll set the canvas size from JS to keep it crisp -->
          <canvas id="gameCanvas" width="480" height="480" tabindex="0" aria-label="Snake game canvas"></canvas>
        </div>

        <div style="width:100%; display:flex; justify-content:center;">
          <div class="hint">Score eats fruit â€” grow longer! Avoid running into walls or yourself.</div>
        </div>
      </section>

      <aside class="panel" aria-hidden="false">
        <div class="stat-row">
          <div>
            <div class="small">Score</div>
            <div class="score" id="score">0</div>
          </div>
          <div>
            <div class="small">Best</div>
            <div class="small" id="best">0</div>
          </div>
        </div>

        <div>
          <label for="speed" class="small">Speed: <span id="speedVal">5</span></label>
          <div class="slider-row">
            <input id="speed" type="range" min="1" max="10" step="1" value="5" />
          </div>
          <div class="small" style="margin-top:8px;">Lower = slower, Higher = faster. You can change speed while playing.</div>
        </div>

        <div>
          <div class="controls" role="group" aria-label="game controls">
            <button id="startBtn">Start</button>
            <button id="pauseBtn" class="ghost">Pause</button>
            <button id="resetBtn" class="ghost">Reset</button>
          </div>
        </div>

        <div>
          <div class="small">Controls</div>
          <div class="small">Arrow keys / WASD to move. Space to pause. Tap canvas to start on mobile.</div>
        </div>

        <div style="margin-top:6px;">
          <div class="small">Settings</div>
          <div class="small">Canvas is 20Ã—20 grid by default; grid scales with screen size.</div>
        </div>

        <div style="margin-top:auto;">
          <div class="small" style="color:#2b5f42;">Tip: increase speed for a bigger challenge â€” but you'll need sharper reflexes!</div>
        </div>
      </aside>

      <footer class="small">Made with ðŸŒ¿ â€” your high score is saved in this browser.</footer>
    </div>
  </div>

<script>
/*
  Snake game (single-file).
  - Grid-based game
  - Speed controlled by slider (1..10)
  - Score and best score saved to localStorage
  - Keyboard controls + tap-to-start
  - Clean, commented code
*/

// ----- Config -----
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let gridSize = 20;           // number of cells per row/col (square grid)
let cellSize = 24;           // px per cell (adjusted at runtime for crispness)
let columns = gridSize;
let rows = gridSize;

let snake = [];              // array of {x,y} for snake body (head at 0)
let dir = { x: 1, y: 0 };    // current moving direction
let nextDir = { x: 1, y: 0 };// used to buffer direction changes
let food = null;             // {x,y}
let score = 0;
let bestScore = 0;
let running = false;
let lastTick = 0;
let tickInterval = 200;      // ms between game updates (modified by speed)
let speedSlider = document.getElementById('speed');
const speedValLabel = document.getElementById('speedVal');

const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');

// initialize best score
bestScore = parseInt(localStorage.getItem('snake_best') || '0', 10);
bestEl.textContent = bestScore;

// responsive canvas sizing for crisp pixel art
function resizeCanvas() {
  // choose the smaller of 72% of available width or fixed max,
  // but ensure cellSize is integer so rendering stays crisp
  const maxDisplay = Math.min(window.innerWidth * 0.65, 720);
  cellSize = Math.max(12, Math.floor(maxDisplay / gridSize));
  canvas.width = cellSize * gridSize;
  canvas.height = cellSize * gridSize;

  // scale for crisp 2D look (no CSS scaling)
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';
  // no need to change ctx scale because we're drawing using cellSize
  render(); // redraw on resize
}

// utilities
function rndInt(max) { return Math.floor(Math.random() * max); }

// reset game state
function resetGame() {
  // center snake horizontally, small length
  const startX = Math.floor(columns / 2);
  const startY = Math.floor(rows / 2);
  snake = [
    { x: startX, y: startY },
    { x: startX - 1, y: startY },
    { x: startX - 2, y: startY }
  ];
  dir = { x: 1, y: 0 };
  nextDir = { x: 1, y: 0 };
  placeFood();
  score = 0;
  scoreEl.textContent = score;
  running = false;
  lastTick = performance.now();
  updateTickIntervalFromSpeed();
  render();
}

// place food at random location not occupied by snake
function placeFood() {
  let tries = 0;
  while (true) {
    const fx = rndInt(columns);
    const fy = rndInt(rows);
    const conflict = snake.some(p => p.x === fx && p.y === fy);
    if (!conflict) {
      food = { x: fx, y: fy };
      return;
    }
    tries++;
    if (tries > 1000) {
      // board may be full â€” win condition: reset food to null
      food = null;
      return;
    }
  }
}

// convert grid coord to pixel rect
function rectFor(x, y) {
  return {
    x: x * cellSize,
    y: y * cellSize,
    w: cellSize,
    h: cellSize
  };
}

// draw rounded rect helper
function drawRect(x, y, w, h, radius=4, fill=true, stroke=false, fillStyle='#000') {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + w, y, x + w, y + h, radius);
  ctx.arcTo(x + w, y + h, x, y + h, radius);
  ctx.arcTo(x, y + h, x, y, radius);
  ctx.arcTo(x, y, x + w, y, radius);
  ctx.closePath();
  if (fill) { ctx.fillStyle = fillStyle; ctx.fill(); }
  if (stroke) { ctx.stroke(); }
}

// rendering functions
function renderGrid() {
  // soft background
  ctx.fillStyle = '#eefaf0';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // subtle tile pattern
  for (let x=0;x<columns;x++){
    for (let y=0;y<rows;y++){
      if ((x + y) % 2 === 0) {
        ctx.fillStyle = 'rgba(47,179,107,0.02)';
        ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
      }
    }
  }

  // border
  ctx.strokeStyle = 'rgba(31,122,76,0.12)';
  ctx.lineWidth = Math.max(1, cellSize * 0.04);
  ctx.strokeRect(0.5, 0.5, canvas.width-1, canvas.height-1);
}

function renderFood() {
  if (!food) return;
  const r = rectFor(food.x, food.y);
  // draw fruit: rounded rectangle with highlight
  drawRect(r.x + 2, r.y + 2, r.w - 4, r.h - 4, Math.max(2, cellSize*0.12), true, false, '#ff6b6b');
  // small leaf
  ctx.fillStyle = '#1f7a4c';
  ctx.beginPath();
  ctx.ellipse(r.x + r.w*0.67, r.y + r.h*0.22, Math.max(2, cellSize*0.12), Math.max(1, cellSize*0.08), -0.6, 0, Math.PI*2);
  ctx.fill();
}

function renderSnake() {
  // head
  if (snake.length === 0) return;
  // body
  for (let i = snake.length - 1; i >= 0; i--) {
    const p = snake[i];
    const r = rectFor(p.x, p.y);
    if (i === 0) {
      // head: brighter
      drawRect(r.x + 1, r.y + 1, r.w - 2, r.h - 2, Math.max(3, cellSize*0.15), true, false, '#1f7a4c');
      // eye (directional)
      ctx.fillStyle = '#eafcf0';
      const eyeSize = Math.max(2, Math.floor(cellSize * 0.12));
      let ex = r.x + (r.w / 2);
      let ey = r.y + (r.h / 2);
      if (dir.x === 1) ex += r.w * 0.18;
      if (dir.x === -1) ex -= r.w * 0.18;
      if (dir.y === 1) ey += r.h * 0.18;
      if (dir.y === -1) ey -= r.h * 0.18;
      ctx.fillRect(Math.floor(ex - eyeSize/2), Math.floor(ey - eyeSize/2), eyeSize, eyeSize);
    } else {
      // gradient body
      const t = i / snake.length;
      const greenShade = lerpColor('#2fb36b', '#1f7a4c', t);
      drawRect(r.x + 1, r.y + 1, r.w - 2, r.h - 2, Math.max(2, cellSize*0.12), true, false, greenShade);
    }
  }
}

// simple color lerp for body gradient
function lerpColor(a, b, t) {
  const A = hexToRgb(a), B = hexToRgb(b);
  const R = Math.round(A.r + (B.r - A.r) * t);
  const G = Math.round(A.g + (B.g - A.g) * t);
  const Bl = Math.round(A.b + (B.b - A.b) * t);
  return `rgb(${R},${G},${Bl})`;
}
function hexToRgb(hex) {
  const h = hex.replace('#','');
  const bigint = parseInt(h, 16);
  if (h.length === 6) {
    return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
  } else { return { r:0,g:0,b:0 }; }
}

// main render
function render() {
  renderGrid();
  renderFood();
  renderSnake();
}

// Game logic tick
function tick() {
  // apply direction buffer
  dir = nextDir;

  // compute new head
  const head = snake[0];
  const nx = head.x + dir.x;
  const ny = head.y + dir.y;

  // collision with walls?
  if (nx < 0 || nx >= columns || ny < 0 || ny >= rows) {
    gameOver();
    return;
  }

  // collision with self?
  const collision = snake.some((s, idx) => idx !== 0 && s.x === nx && s.y === ny);
  if (collision) {
    gameOver();
    return;
  }

  // move: add new head
  snake.unshift({ x: nx, y: ny });

  // eat food?
  if (food && nx === food.x && ny === food.y) {
    score += 1;
    scoreEl.textContent = score;
    // update best
    if (score > bestScore) {
      bestScore = score;
      bestEl.textContent = bestScore;
      localStorage.setItem('snake_best', bestScore.toString());
    }
    placeFood();
  } else {
    // remove tail
    snake.pop();
  }
}

// gameOver visual & reset running state
function gameOver() {
  running = false;
  // flash red overlay quickly
  const duration = 240;
  const start = performance.now();
  function flash(now) {
    const t = (now - start) / duration;
    render();
    ctx.fillStyle = `rgba(255,80,80,${0.32 * (1 - Math.max(0, Math.min(1, t)))})`;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    if (t < 1) requestAnimationFrame(flash);
  }
  requestAnimationFrame(flash);
}

// main loop using requestAnimationFrame, but only advance game at tickInterval
function loop(now) {
  if (!lastTick) lastTick = now;
  const elapsed = now - lastTick;
  if (running && elapsed >= tickInterval) {
    // run one tick (can run multiple if very slow, but cap)
    const maxTicks = Math.floor(elapsed / tickInterval);
    for (let i=0;i<maxTicks;i++) {
      tick();
      lastTick += tickInterval;
    }
  }
  render();
  requestAnimationFrame(loop);
}

// input handlers
window.addEventListener('keydown', (e) => {
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D',' '].includes(e.key)) {
    e.preventDefault();
  }
  if (!running && (e.key === ' ' || e.key === 'Spacebar')) {
    // toggle pause/start
    toggleRunning();
    return;
  }
  switch (e.key) {
    case 'ArrowUp': case 'w': case 'W':
      if (dir.y === 0) nextDir = { x: 0, y: -1 };
      break;
    case 'ArrowDown': case 's': case 'S':
      if (dir.y === 0) nextDir = { x: 0, y: 1 };
      break;
    case 'ArrowLeft': case 'a': case 'A':
      if (dir.x === 0) nextDir = { x: -1, y: 0 };
      break;
    case 'ArrowRight': case 'd': case 'D':
      if (dir.x === 0) nextDir = { x: 1, y: 0 };
      break;
    case ' ':
      toggleRunning();
      break;
  }
});

// touch / click to start (mobile)
canvas.addEventListener('pointerdown', (e) => {
  // start if not running
  if (!running) toggleRunning();
});

// speed slider
function updateTickIntervalFromSpeed() {
  // speed 1 (slow) => 320 ms; speed 10 (fast) => 60 ms (nonlinear mapping)
  const s = parseInt(speedSlider.value, 10);
  speedValLabel.textContent = s;
  // map to ms: use exponential-ish mapping for fine control
  const min = 48; const max = 360;
  const pct = (s - 1) / (10 - 1);
  tickInterval = Math.round(max - (max - min) * Math.pow(pct, 1.2));
}

// UI buttons
startBtn.addEventListener('click', () => {
  if (!running) {
    startGame();
  }
});
pauseBtn.addEventListener('click', () => {
  toggleRunning();
});
resetBtn.addEventListener('click', () => {
  resetGame();
});

speedSlider.addEventListener('input', () => {
  updateTickIntervalFromSpeed();
});

// start/pause helpers
function startGame() {
  if (!running) {
    running = true;
    lastTick = performance.now();
  }
}
function toggleRunning() {
  running = !running;
  pauseBtn.classList.toggle('ghost', !running);
  pauseBtn.textContent = running ? 'Pause' : 'Resume';
  // if starting first time ensure game begins properly
  if (running && snake.length === 0) resetGame();
}

// init & start loop
function init() {
  // bind size and initial state
  resizeCanvas();
  window.addEventListener('resize', () => {
    resizeCanvas();
  });

  // initialize game state
  resetGame();
  updateTickIntervalFromSpeed();

  // start animation loop
  requestAnimationFrame(loop);
}

// reset on load
init();

</script>
</body>
</html>
